#!/bin/bash

#  Copyright (c) 2009-2010 Wind River Systems, Inc.

#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License version 2 as
#  published by the Free Software Foundation.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#  See the GNU General Public License for more details.

# Generate kernel config file from fragments.
# The idea is that the auditing would be done in kconf_check, however
# there are some things that it is just easier to check for and collect
# data on here (i.e. if frag A and frag B both list item X).

KERNEL_CONFIG=$1
TOP_BUILD_DIR=$2
LINUX_DIST=$3
LINUX_BUILD=$4
BRANCH=$5

# For consistent behaviour with "grep -w"
LC_ALL=C
export LC_ALL

if [ -d $TOP_BUILD_DIR ]; then
	# For TARGET_BOARD
	. $TOP_BUILD_DIR/config.sh
	WRS_DIR=$TOP_BUILD_DIR/build/$LINUX_BUILD/meta
	if [ ! -d "$WRS_DIR" ]; then
	    WRS_DIR=$TOP_BUILD_DIR/build/$LINUX_BUILD/wrs
	fi
else
	WRS_DIR=`pwd`/meta
	if [ ! -d "$WRS_DIR" ]; then
	    WRS_DIR=`pwd`/wrs
	fi
fi

KCONF_DIR=$WRS_DIR/cfg/$BRANCH

# On the fly list of all known hardware related Kconfig* files
KCONF_HDW=$KCONF_DIR/hardware.kcf
# Same for all known non-hardware related Kconfig* files
KCONF_NONHDW=$KCONF_DIR/non-hardware.kcf

# On the fly override for hardware CONFIG items that are 
# in a non-hardware Kconfig.
CONF_HDW=$KCONF_DIR/always_hardware.cfg
# Same for non-hardware CONFIG items that are in a hardware Kconfig.
CONF_NONHDW=$KCONF_DIR/always_nonhardware.cfg

# Log any redefinitions/overrides that take place
KCONF_OVERRIDE=$KCONF_DIR/redefinition.txt
# Egads. People are listing the same thing multiple times within a fragment.
#  An evil sin that deserves its own category (and insults).
KCONF_FRAG_ERRS=$KCONF_DIR/fragment_errors.txt
# Log items that were defined as 'generic' (aka software) and were changed
# to hardware specific. This is a borderline error.
KCONF_REDFINED_AS_BOARD_SPECIFIC=$KCONF_DIR/redefined_as_board_specific.txt

# By setting this flag, we won't warn if two config fragments set 
# a value and they are the same. We'll continue to warn if they
# change them.
if [ -z "$ALLOW_OVERLAPPING_CONFIGS" ]; then
	ALLOW_OVERLAPPING_CONFIGS=t
fi

NEW_KERNEL_CFG=$KCONF_DIR/$KERNEL_CONFIG-new
OLD_KERNEL_CFG=$KCONF_DIR/$KERNEL_CONFIG

rm -f $KCONF_OVERRIDE
rm -f $KCONF_FRAG_ERRS

# Take a fragment and append it to the existing collection of fragments.
# If CONFIG_FOO is being redefined by the appended fragment, then filter
# out the definition from the existing collection 1st.
# Since we end up appending from a scratch file instead of the original
# possibly messed up fragment, we need to know what the original
# source of the data was, hence arg #3.  The scratch file has already
# been sanitized, so no need to grep out just the CONFIG_ lines -- that
# is all there is in the file now.
function append_and_filter ()
{
	ORIG=$1
	APPEND=$2
	SRCFILE=$3
	echo "#" >> $ORIG
	echo "# Begin: $SRCFILE" >> $ORIG
	CFG_LIST=`cat $APPEND | \
	  sed 's/^\(# \)\{0,1\}\(CONFIG_[a-zA-Z0-9_]*\)[= ].*/\2/'`
	for i in $CFG_LIST ; do
		grep -q -w $i $ORIG
		if [ $? == 0 ] ; then
			OLD_VALUE=`grep -w $i $ORIG`
			NEW_VALUE=`grep -w $i $APPEND`
			# if overlapping configs are allowed, only warn if it
			# changed. And only then warn if it wasn't a hardware
			# option being set.
			if [ -n "$ALLOW_OVERLAPPING_CONFIGS" ]; then
				if [ "$OLD_VALUE" != "$NEW_VALUE" ]; then
					grep -q -w $i $CONF_HDW
					if [ $? -ne 0 ]; then
						echo Value of $i is redefined by fragment $SRCFILE:
						echo Old value: `grep -w $i $ORIG`
						echo New value: `grep -w $i $APPEND`
						echo
					fi
				fi
			else
				echo Value of $i is redefined by fragment $SRCFILE:
				echo Old value: `grep -w $i $ORIG`
				echo New value: `grep -w $i $APPEND`
				echo
			fi
			mv -f $ORIG $ORIG~
			cat $ORIG~ | grep -v -w $i > $ORIG
			rm -f $ORIG~
		fi
	done
	cat $2 | grep -v '^\.' | sed '/^$/d' >> $ORIG
}

# This is used to filter out duplicate declarations within a single
# fragment.  People shouldn't do this, but we must behave predictably
# if they do...   Also check for lines that start with "# CONFIG_"
# but don't end with the all so important " is not set" -- as this
# always seems to surprise people who think the leading hash is all
# that matters.
function sanitize_fragment ()
{
	DIRTY_FRAG=$1
	CLEAN_FRAG=$2
	rm -f $CLEAN_FRAG
	touch $CLEAN_FRAG
	CFG_LIST=`grep '^\(# \)\{0,1\}CONFIG_[a-zA-Z0-9_]*[=\( is not set\)]' \
	  $DIRTY_FRAG | sed 's/^\(# \)\{0,1\}\(CONFIG_[a-zA-Z0-9_]*\)[= ].*/\2/'`
	for i in $CFG_LIST ; do
		LASTVAL=`grep -w $i $DIRTY_FRAG | tail -n1`
		echo $LASTVAL|grep -q '^# CONFIG_'
		HEAD_OK=$?
		echo $LASTVAL|grep -q ' is not set$'
		TAIL_OK=$?

		grep -q -w $i $CLEAN_FRAG
		if [ $? == 0 ] ; then	
			echo Warning: Value of $i is defined multiple times within fragment $DIRTY_FRAG:
			grep -w $i $DIRTY_FRAG
			echo
		elif [ $HEAD_OK -eq 0 ] && [ $TAIL_OK -ne 0 ]; then
			# Enforce proper "# CONFIG_FOO is not set" syntax.
			# LKC would ignore it anyway, so let them know.
			echo Warning: Ignoring \"$LASTVAL\" -- invalid CONFIG syntax.
		else
			echo $LASTVAL >> $CLEAN_FRAG
		fi
	done
}

# ****************
# main()
# ****************

# First create header that lists all the fragments.
echo "#" > $NEW_KERNEL_CFG
echo "# NOTE: This file is for informational purposes only." >> $NEW_KERNEL_CFG
echo "# Changes made to this file will NOT be processed/used." >> $NEW_KERNEL_CFG
echo "#" >> $NEW_KERNEL_CFG
echo "# This file has been automatically generated from " >> $NEW_KERNEL_CFG
echo "# the following set of configure files: " >> $NEW_KERNEL_CFG
for f in `cat $KCONF_DIR/config_frag.txt`; do
	if [ -f $WRS_DIR/cfg/$f ]; then
		echo "# $f" >> $NEW_KERNEL_CFG
	fi
done

echo "#" >> $NEW_KERNEL_CFG
echo "# Local copies of these fragments are all found in the directory:" >> $NEW_KERNEL_CFG
echo "# 	$WRS_DIR/cfg/" >> $NEW_KERNEL_CFG

rm -f $KCONF_OVERRIDE $KCONF_FRAG_ERRS $KCONF_NONHDW $KCONF_HDW \
	$CONF_NONHDW $CONF_HDW

# Assemble fragments and collect lists of new/added Kconfigs
# 1st pass is to just collect all the state info -- i.e. the
# categorization of Kconfigs and hardware specific opts.
# Then we have all the data we need to audit things properly.

for f in `cat $KCONF_DIR/config_frag.txt`; do
	# The input line is the Host path into the kernel-next cache.
	frag_subpath=`dirname $f`
	# This references the wrs dir; we aren't touching the
	# ones in the kernel-cache at this point.
	frag_dir=$WRS_DIR/cfg/$frag_subpath

	# Possible fixme -- could check hdw additions against the non-hdw
	# and vice versa -- it would allow folks to mask things.
	# See alternate solution just at the bottom of this loop.
	if [ -f $frag_dir/non-hardware.kcf ]; then
		cat $frag_dir/non-hardware.kcf | grep -v '^#' | \
			sed '/^$/d' >> $KCONF_NONHDW
	fi
	if [ -f $frag_dir/hardware.kcf ]; then
		cat $frag_dir/hardware.kcf | grep -v '^#' | \
			sed '/^$/d' >> $KCONF_HDW
	fi
	if [ -f $frag_dir/non-hardware.cfg ]; then
		cat $frag_dir/non-hardware.cfg | grep -v '^#' | \
			sed '/^$/d' >> $CONF_NONHDW
	fi
	if [ -f $frag_dir/hardware.cfg ]; then
		cat $frag_dir/hardware.cfg | grep -v '^#' | \
			sed '/^$/d' >> $CONF_HDW
	fi
done

if [ ! -f $KCONF_NONHDW ]; then
    touch $KCONF_NONHDW
fi
if [ ! -f $KCONF_HDW ]; then
    touch $KCONF_HDW
fi
if [ ! -f $CONF_NONHDW ]; then
    touch $CONF_NONHDW
fi
if [ ! -f $CONF_HDW ]; then
    touch $CONF_HDW
fi

# Nobody ever specifies things as non-hardware.  All they ever do is lie like
# a cheap rug and say that things that aren't hardware really are (like
# turning on a fs in a BSP) and then cheating to mask the warning).  So
# rather than filter all hardware from non hdw on the fly for each new
# addition, as mentioned above - simply instead ensure anything listed in the
# hardware list *doesnt* appear in the non-hdw list.
#
# But this qualifies as a redefintion as something that wasn't board specific
# to something that IS board specific. So we should log it, and make it an
# informational message.
#
mv -f $CONF_NONHDW $CONF_NONHDW~
cat $CONF_NONHDW~ | grep -v -w -f $CONF_HDW > $CONF_NONHDW
# the difference between what was 'non hardware' and 'hardware' means that
# it was re-defined to be board specific. We should log this change and 
# report it later
cat $CONF_NONHDW~ | grep -w -f $CONF_HDW > $KCONF_REDFINED_AS_BOARD_SPECIFIC
rm -f $CONF_NONHDW~

for f in `cat $KCONF_DIR/config_frag.txt`; do
	# The input line is the Host path into the kernel-next cache.
	frag_subpath=`dirname $f`
	frag_dir=$WRS_DIR/cfg/$frag_subpath
	# This references the frag in the wrs dir; we aren't touching the
	# ones in the kernel-cache at this point.
	frag=$WRS_DIR/cfg/$f

        # echo "[INFO] Processing $frag"

	if [ -f $frag ]; then
		rm -f $KCONF_DIR/.scratch
		touch $KCONF_DIR/.scratch
		sanitize_fragment  $frag $KCONF_DIR/.scratch >> $KCONF_FRAG_ERRS
		append_and_filter $NEW_KERNEL_CFG $KCONF_DIR/.scratch \
			$frag >> $KCONF_OVERRIDE
		rm -f $KCONF_DIR/.scratch
	else
		echo "[ERROR] Kern frag $frag does not exist"
		exit 1
	fi

done


# Preserve old file (and associated timestamps) if content is unchanged
if [ -f $OLD_KERNEL_CFG ]; then
	cmp -s $NEW_KERNEL_CFG $OLD_KERNEL_CFG
	if [ $? != 0 ]; then
		mv -f $OLD_KERNEL_CFG $OLD_KERNEL_CFG.old
		mv -f $NEW_KERNEL_CFG $OLD_KERNEL_CFG
	else
		rm -f $NEW_KERNEL_CFG
	fi
else
	mv -f $NEW_KERNEL_CFG $OLD_KERNEL_CFG
fi

if [ ! -f $OLD_KERNEL_CFG ]; then
	echo Error: Problem creating kernel config: $OLD_KERNEL_CFG 
	exit 1
fi
