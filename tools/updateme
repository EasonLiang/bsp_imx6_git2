#!/bin/bash

# "updateme" script.

#  Copyright (c) 2010 Wind River Systems, Inc.

#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License version 2 as
#  published by the Free Software Foundation.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#  See the GNU General Public License for more details.

#  This script must be run from inside a Linux source directory

usage()
{
cat << EOF

    updateme <dirs>

EOF
}

if [ -d "wrs" ]; then
    meta_dir=wrs
else
    meta_dir=meta
fi

if [ -z "$1" ]; then
	usage
	exit
fi

while [ $# -gt 0 ]; do
	case "$1" in
	    --help)
		usage
		exit
	        ;;
	    --features)
		cmd_line_features="$2"
		shift
		;;
	    --force)
		force=t
		;;
	    -v) verbose=t
		;;
	    *) break
		;;
	esac
	shift
done

# arg1 is the ARCH
arch=$1
shift
# everything else is features
command_line_dirs=$@
CURRENT=`git branch |grep \*|sed 's/^\* //'`

gen_dirs() {
	top_dir=$1

	potential=`find $top_dir -maxdepth 3 -type d -name kernel*cache`
	for dir in $potential; do
	    search_dirs="$search_dirs $dir"
	    includes="$includes -I $dir"
	done
}

# searches for extra files to build
find_features() {
	dirs=$@

	for d in $dirs; do
	    potential=`find $d -maxdepth 1 -type f -name *.scc`
	    extra_features="$extra_features $potential"
	done
}

# searches for extra configs to include, only if they haven't
# been pulled into a .scc file already
find_configs() {
	dirs=$@
	
	# defconfigs should be found first, so fragements can tweak
	# settings
	for d in $dirs; do
	    potential=`find $d -maxdepth 1 -type f -name defconfig`
	    scc_files=`find $d -maxdepth 1 -type f -name *.scc` 
	    for c in $potential; do
		b=`basename $c`
		f=`readlink -f $c`
	    	# check to see if a .scc file already includes the fragement
		if [ -n "$scc_files" ]; then
			grep $b $d/*.scc -q
			if [ $? -ne 0 ]; then
		    		extra_cfgs="$extra_cfgs $f"
			fi
		else
			extra_cfgs="$extra_cfgs $f"
		fi
	    done
	done

	for d in $dirs; do
	    potential=`find $d -maxdepth 1 -type f -name *.cfg`
	    scc_files=`find $d -maxdepth 1 -type f -name *.scc` 
	    for c in $potential; do
		b=`basename $c`
		f=`readlink -f $c`
	    	# check to see if a .scc file already includes the fragement
		if [ -n "$scc_files" ]; then
			grep $b $d/* -q
			if [ $? -ne 0 ]; then
		    		extra_cfgs="$extra_cfgs $f"
			fi
		else
			extra_cfgs="$extra_cfgs $f"
		fi
	    done
	done
}

# searches for extra patches to include, only if they haven't
# been pulled into a .scc file already
find_patches() {
	dirs=$@
	
	for d in $dirs; do
	    potential=`find $d -maxdepth 1 -type f -name *.patch`
	    potential="$potential `find $d -maxdepth 1 -type f -name *.diff`"
	    potential="$potential `find $d -maxdepth 1 -type f -name *.mbox`"
	    for c in $potential; do
		b=`basename $c`
		f=`readlink -f $c`
	    	# check to see if a .scc file already includes the patch
		grep $b $d/* -q
		if [ $? -ne 0 ]; then
		    extra_patches="$extra_patches $f"
		fi
	    done
	done
}

do_compile_prep() {
	top_dir=$1

	mkdir -p $meta_dir/cfg/meta/obj
	(cd $meta_dir/cfg/meta/obj
	    rm -f *.sco
	)

	# updates 'includes' and 'search_dirs'
	gen_dirs $top_dir
	includes="-I $top_dir $includes"
	search_dirs="$top_dir $search_dirs"
}

search_includes()
{
	search_expr=$1
	parent_leaf=$2
	search_tgt=

	for dir in $search_dirs; do
            if [ -n "$search_tgt" ]; then
		continue
            fi

            found=`find $dir/ -regex "$search_expr"`
            if [ -n "$found" ]; then
		for f in $found; do
                    if [ -n "$search_tgt" ]; then
			continue
                    fi
                    if [ "$parent_leaf" != "any" ]; then
			x=`grep "scc_leaf" $f`
			if [ -n "$x" ]; then
                            echo "$x" | grep -q -w $parent_leaf
                            if [ $? -eq 0 ]; then
				search_tgt=$f
                            fi
			fi
                    else
			search_tgt=$f
                    fi
		done
            fi
	done

	echo $search_tgt
}

do_update() {
	branch=$1
	top_dir=$2

	# we need to condition the branch. If it is in the form that
	# uses / for inheritance, special processing needs to be done.
	echo $branch | grep -q "/"
	if [ $? -eq 0 ]; then
	    # remove trailing "/base" that won't be in the .scc files themselves
	    tgt=`echo $branch | sed 's%/base$%%'`
	    # the parent branch is the second to last, i.e. standard/common_pc
	    # so we can reverse everything and take the second field
	    parent=`echo $tgt | rev | cut -d'/' -f2 | rev`
	    short_branchname=`echo $tgt | rev | cut -d'/' -f1 | rev`
	    ktgt=$short_branchname-$parent
	else
	    ktgt=$branch
	    short_branchname=$branch
	    parent=`echo $ktgt | rev | cut -d'-' -f1 | rev`
	fi

	top_tgt=`search_includes ".*/$ktgt.scc" any`
	if [ -z "$top_tgt" ]; then
		# try _'s instead of -'s
		search_pattern=`echo $ktgt | sed 's/-/.\*/g'`
		top_tgt=`search_includes ".*/$search_pattern.scc" any`
	fi

        # if there isn't a target .. we'll need to create one
	if [ -z "$top_tgt" ]; then
	    target=${ktgt%-*}

	    # we need to generate a baseline configuration
	    (cd $meta_dir/cfg/meta/obj
		echo "# auto generated BSP file" > $ktgt.scc
		echo "define WRS_BOARD $target" >> $ktgt.scc
		echo "define WRS_KERNEL $parent" >> $ktgt.scc
		echo "define WRS_ARCH $arch" >> $ktgt.scc
		echo "" >> $ktgt.scc

		echo "scc_leaf ktypes/$parent $short_branchname" >> $ktgt.scc
	    )

	    top_tgt=$meta_dir/cfg/meta/obj/$ktgt.scc
	fi

	# this builds and applies the meta-series
	( cd $meta_dir/cfg/meta/obj
	    if [ -n "$extra_cfgs" ]; then
		for c in $extra_cfgs; do
		    b=`basename $c`
		    cp $c .
		    echo "kconf non-hardware $b" >> auto_feat.scc
		done
	    
		extra_features="$extra_features auto_feat.scc"
	    fi

	    if [ -n "$extra_patches" ]; then
		for c in $extra_patches; do
		    b=`basename $c`
		    cp $c .
		    echo "patch $b" >> auto_feat.scc
		done
	    
		echo "$extra_features" | grep -q auto_feat.scc
		if [ $? -ne 0 ]; then
		    extra_features="$extra_features auto_feat.scc"
		fi
	    fi

	    scc -o $ktgt $includes $top_tgt $extra_features $addon_features

	    if [ -e "$ktgt" ]; then
		bash ./$ktgt > ../$ktgt-meta
	    else
		echo "ERROR. Could not find an excutable target for $branch"
	    fi
	)
}

process_args()
{
	args=$@

	for a in $args; do
		if [ -d $a ]; then
			feature_dirs="$feature_dirs $a"
		else
			features_to_find="$features_to_find $a"	
		fi
	done
}


_strip_ext()
{
    # this isn't quite "basename" we want the full
    # path, just no extension, i.e. without basename's
    # habit of removing the last element no matter what
    local name=$1
    local ext=$2

    if [ -n "$ext" ]; then
	echo "$name" | sed "s%$ext$%%"
    else
	echo $name
    fi
}

do_addon_features()
{
	feats=$@

	for f in $feats; do
		for d in $search_dirs; do
		        search_feat=`_strip_ext $f .scc`
			potential=`find $d | grep -E ".*$search_feat.*\.scc"`
			if [ -n "$potential" ]; then
				addon_features="$addon_features $potential"
			else
				if [ -e "$d/$f" ]; then
				        # if it is a directory, only pass the dir name.
					if [ -d "$d/$f" ]; then
						addon_features="$addon_features $f"
					else
						addon_features="$addon_features $d/$f"
					fi
				fi
			fi
		done
	done
}


# $PWD is the Linux src directory
linux_src_dir=`pwd`

do_compile_prep $linux_src_dir

# sorts the command line options and returns "feature_dirs" and 
# "features_to_find"
process_args $command_line_dirs

find_features $feature_dirs
find_configs $feature_dirs
find_patches $feature_dirs

do_addon_features $cmd_line_features $features_to_find

do_update $CURRENT $linux_src_dir
