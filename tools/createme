#!/bin/bash

# "createme" script.

#  Copyright (c) 2010 Wind River Systems, Inc.

#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License version 2 as
#  published by the Free Software Foundation.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#  See the GNU General Public License for more details.

#  This script must be run from inside a Linux source directory

usage()
{
cat << EOF

    createme [-v] [--disable-meta-gen] <arch> <branch> [defconfig]

      --disable-meta-gen: do not automatically create meta data
                          if not already present in the source tree.
      -v: verbose processing
      <arch>: the kernel architecture being processed
      <branch>: repository branch to use or create

EOF
}


meta_dir=meta
if [ -z "$1" ]; then
	usage
	exit
fi

while [ $# -gt 0 ]; do
	case "$1" in
	    --help)
		usage
		exit
		;;
            --disable-meta-gen)
                must_have_meta=t
                ;;
	    --force)
		force=t
		;;
	    -v) verbose=t
		;;
	    *) break
		;;
	esac
	shift
done

arch=$1
branch=$2
defconfig=$3 # might be empty
CURRENT=`git branch |grep \*|sed 's/^\* //'`
repo=

check_repo()
{
	action=$1

	git show-ref --quiet --verify -- "refs/heads/wrs_meta"
	if [ $? -eq 0 ]; then
		meta_branch=wrs_meta
	fi
	git show-ref --quiet --verify -- "refs/heads/meta"
	if [ $? -eq 0 ]; then
		meta_branch=meta
	fi

	if [ "$action" = "sanitize" ]; then
		git show-ref --quiet --verify -- "refs/tags/checkpoint-$meta_branch"
		if [ $? -eq 1 ]; then
			if [ -n "$must_have_meta" ]; then
				echo "ERROR. meta data not found, check upstream repo for tags and branches"
				exit 1
			else
				echo "WARNING: checkpoint tag not found, creating .."
				git tag "checkpoint-$meta_branch"
			fi
		fi
	else
		if [ -n "$meta_branch" ]; then
			echo "meta-data"
		else	    
			echo "external"
		fi
	fi
}

metaize()
{
	mkdir -p $meta_dir/cfg/kernel-cache
	mkdir -p $meta_dir/cfg/kernel-cache/ktypes/standard
	echo "# autogenerated standard kernel" >> $meta_dir/cfg/kernel-cache/ktypes/standard/standard.scc
	echo "branch yocto/standard" >> $meta_dir/cfg/kernel-cache/ktypes/standard/standard.scc
	version=`grep -E "^VERSION =" Makefile | cut -d\= -f2 | sed 's/ //g'`
	patchlevel=`grep -E "^PATCHLEVEL =" Makefile | cut -d\= -f2 | sed 's/ //g'`
	sublevel=`grep -E "^SUBLEVEL =" Makefile | cut -d\= -f2 | sed 's/ //g'`
	echo -n "v" >> $meta_dir/cfg/kernel-cache/kver
	echo -n "$version" >> $meta_dir/cfg/kernel-cache/kver
	echo -n "." >> $meta_dir/cfg/kernel-cache/kver
	echo -n "$patchlevel" >> $meta_dir/cfg/kernel-cache/kver
	echo -n "." >> $meta_dir/cfg/kernel-cache/kver
	echo "$sublevel" >> $meta_dir/cfg/kernel-cache/kver
}

# Steal the wrs data off of the wrs_meta branch, but dont actually
# change the meta in the process...
decheckpoint()
{	
	check_repo sanitize
	case `check_repo identify` in
		meta-data)
	       		repo=meta-data
			kgit-checkpoint -r
			;;
		external)
			if [ -n "$must_have_meta" ]; then
				echo "ERROR. meta data not found. Check upstream kernel for tags and branches"
				exit 1
			fi
			repo=external
		        metaize
			;;
	esac

	if [ -d wrs ]; then
		meta_dir=wrs
	else
		meta_dir=meta
	fi
}

# checks and sets
check_defconfig() {
	config=$1

	defconfig=`get_defconfig $arch $config`
}

# checks and creates
check_branch() {
	branch=$1
	defconfig=$2

	ktgt=$branch

	old_pwd=`pwd`
	git show-ref --quiet --verify -- "refs/heads/$ktgt"
	if [ $? -eq 1 ]; then
	    if [ -n "$verbose" ]; then
		echo "[INFO] branch $branch does not exist ... creating"
	    fi

            # we need to condition the branch. If it is in the form that
	    # uses / for inheritance, special processing needs to be done.
            echo $ktgt | grep -q "/"
	    if [ $? -eq 0 ]; then
    	        # remove trailing "/base" that won't be in the .scc files
    	        # themselves
		tgt=`echo $ktgt | sed 's%/base$%%'`
		target=`echo $tgt | rev | cut -d'/' -f1 | rev`
		parent=`echo $tgt | sed "s%/$target%%"`
		
		# parent may be a "base" branch, so we test
		git show-ref --quiet --verify -- "refs/heads/$parent"
		if [ $? -eq 1 ]; then
		    git show-ref --quiet --verify -- "refs/heads/$parent/base"
		    if [ $? -eq 1 ]; then
			# fallback
			parent=$CURRENT
		    else
			parent="$parent/base"
		    fi
		fi
            else
		parent=`echo $ktgt | rev | cut -d'-' -f1 | rev`
	    fi

	    if [ "$parent" != "$CURRENT" ]; then
		git checkout -b $ktgt $parent
	    fi
	
	    mkdir -p $meta_dir/cfg/scratch/obj
	    cd $meta_dir/cfg/scratch/obj

	    # only process the defconfig if we are creating the branch, otherwise, 
	    # you need to add configuration via "updateme"
	    if [ -f $defconfig ]; then
		cp -f $defconfig $old_pwd/../defconfig
	    fi

	    (cd $old_pwd; find -name 'Kconfig' | sed 's/^.\///' > $meta_dir/cfg/scratch/obj/hardware.kcf)
	fi
}


decheckpoint
check_defconfig $defconfig
check_branch $branch $defconfig
