#!/usr/bin/perl -w

=head1 NAME

dh_systemd_disable - disable systemd unit files

=cut

use strict;
use Debian::Debhelper::Dh_Lib;
use File::Find;
use Text::ParseWords qw(shellwords); # in core since Perl 5

=head1 SYNOPSIS

B<dh_systemd_disable> [S<I<debhelper options>>] [B<--disable-in-prerm>] [S<I<unit file> ...>]

=head1 DESCRIPTION

B<dh_systemd_disable> is a debhelper program that is responsible for disabling
systemd unit files.

In the simple case, it finds all unit files installed by a package (e.g.
bacula-fd.service) and disables them. It is not necessary that the machine
actually runs systemd during package installation time, enabling happens on all
machines in order to be able to switch from sysvinit to systemd and back.

In the complex case, you can call B<dh_systemd_disable> and B<dh_systemd_start>
manually (by overwriting the debian/rules targets) and specify flags per unit
file. An example is colord, which ships colord.service, a dbus-activated
service without an [Install] section. This service file cannot be disabled or
disabled (a state called "static" by systemd) because it has no
[Install] section. Therefore, running dh_systemd_disable does not make sense.

=head1 OPTIONS

=over 4

=item B<--disable-in-prerm>

Call deb-systemd-helper disable in prerm instead of postrm (calling it in
postrm is the default).

This is necessary in cases where stopping the service can only be done after
the service file has been disabled. As an example, take rsyslog: due to its
socket activation, it would get re-enabled immediately when trying to stop it
as long as there is something on your machine writing to syslog. Even worse,
this actually makes the stop call fail. Using --disable-in-prerm helps here.

We cannot make this flag the default behavior because for other cases it breaks
things, e.g. when you have a systemd service file which is called differently
than the corresponding init script and uses Alias= to handle that behavior
(e.g. NetworkManager).

=item B<-r>, B<--no-restart-on-upgrade>

Do not stop service on upgrade.

=back


=head1 NOTES

Note that this command is not idempotent. L<dh_prep(1)> should be called
between invocations of this command (with the same arguments). Otherwise, it
may cause multiple instances of the same text to be added to maintainer
scripts.

Note that B<dh_systemd_disable> should be run after B<dh_installinit>.
The default sequence in B<dh> does the right thing, this note is only relevant
when you are calling B<dh_systemd_after> manually.

=cut

init(options => {
	"no-also" => \$dh{NO_ALSO},
	"disable-in-prerm" => \$dh{DISABLE_IN_PRERM},
});

# Extracts the Also= or Alias= line(s) from a unit file.
# In case this produces horribly wrong results, you can pass --no-also, but
# that should really not be necessary. Please report bugs to
# pkg-systemd-maintainers.
sub extract_key {
	my ($unit_path, $key) = @_;
	my @values;
	my $fh;

	if ($dh{NO_ALSO}) {
		return @values;
	}

	if (!open($fh, '<', $unit_path)) {
		warning("Cannot open($unit_path) for extracting the Also= line(s)");
		return;
	}
	while (my $line = <$fh>) {
		chomp($line);

		if ($line =~ /^\s*$key=(.+)$/i) {
			@values = (@values, shellwords($1));
		}
	}
	close($fh);
	return @values;
}

foreach my $package (@{$dh{DOPACKAGES}}) {
	my $tmpdir = tmpdir($package);
	my @installed_units;
	my @units;
	my %aliases;

	# XXX: This is duplicated in dh_installinit, which is unfortunate.
	# We do need the service files before running dh_installinit though,
	# every other solution makes things much worse for all the maintainers.

	# Figure out what filename to install it as.
	my $script;
	my $jobfile=$package;
	if (defined $dh{NAME}) {
		$jobfile=$script=$dh{NAME};
	}
	elsif ($dh{D_FLAG}) {
		# -d on the command line sets D_FLAG. We will
		# remove a trailing 'd' from the package name and
		# use that as the name.
		$script=$package;
		if ($script=~m/(.*)d$/) {
			$jobfile=$script=$1;
		}
		else {
			warning("\"$package\" has no final d' in its name, but -d was specified.");
		}
	}
	elsif ($dh{INIT_SCRIPT}) {
		$script=$dh{INIT_SCRIPT};
	}
	else {
		$script=$package;
	}

	my $service=pkgfile($package,"service");
	if ($service ne '') {
		my $path="$tmpdir/lib/systemd/system";
		if (! -d "$path") {
			doit("install","-d","$path");
		}

		doit("install","-p","-m644",$service,"$path/$script.service");
	}

	my $tmpfile=pkgfile($package,"tmpfile");
	if ($tmpfile ne '') {
		my $path="$tmpdir/usr/lib/tmpfiles.d";
		if (! -d "$path") {
			doit("install","-d","$path");
		}

		doit("install","-p","-m644",$tmpfile,"$path/$script.conf");
	}

	find({
		wanted => sub {
			my $name = $File::Find::name;
			return unless -f $name;
			return unless $name =~ m,^$tmpdir/lib/systemd/system/[^/]+$,;
			push @installed_units, $name;
		},
		no_chdir => 1,
	}, $tmpdir);

	# Handle either only the unit files which were passed as arguments or
	# all unit files that are installed in this package.
	my @args = @ARGV > 0 ? @ARGV : @installed_units;

	# This hash prevents us from looping forever in the following while loop.
	# An actual real-world example of such a loop is systemdâ€™s
	# systemd-readahead-drop.service, which contains
	# Also=systemd-readahead-collect.service, and that file in turn
	# contains Also=systemd-readahead-drop.service, thus forming an endless
	# loop.
	my %seen;

	# We use while/shift because we push to the list in the body.
	while (@args) {
		my $name = shift @args;
		my $base = basename($name);

		# Try to make the path absolute, so that the user can call
		# dh_installsystemd bacula-fd.service
		if ($base eq $name) {
			# NB: This works because @installed_units contains
			# files from precisely one directory.
			my ($full) = grep { basename($_) eq $base } @installed_units;
			if (defined($full)) {
				$name = $full;
			} else {
				warning(qq|Could not find "$name" in the /lib/systemd/system of $package.| .
					qq|This could be a typo, or using Also= with a service file from another package.| .
					qq|Please check carefully that this message is harmless.|);
			}
		}

		# Skip template service files like e.g. getty@.service.
		# Enabling, disabling, starting or stopping those services
		# without specifying the instance (e.g. getty@ttyS0.service) is
		# not useful.
		if ($name =~ /\@/) {
			next;
		}

		# Handle all unit files specified via Also= explicitly.
		# This is not necessary for enabling, but for disabling, as we
		# cannot read the unit file when disabling (it was already
		# deleted).
		my @also = grep { !exists($seen{$_}) } extract_key($name, 'Also');
		$seen{$_} = 1 for @also;
		@args = (@args, @also);

		$aliases{$name} = [ extract_key($name, 'Alias') ];
		push @units, $name;
	}

	next if @units == 0;

	# These autoscripts contain a call to deb-systemd-helper disable,
	# which needs to have all Aliases passed explicitly
	# in order to properly cleanup the state file (the
	# information is stored only in the symlinks which the
	# admin might have removed).
	my @both = @units;
	for my $unit (@units) {
		@both = (@both, @{$aliases{$unit}});
	}

	my $unitargs = join(" ", map { basename($_) } @both);
	my $filename = "postrm";
	if ($dh{DISABLE_IN_PRERM}) {
		$filename = "prerm";
	}
	autoscript($package, $filename, "postrm-systemd", "s/#UNITFILES#/$unitargs/");

	# init-system-helpers ships deb-systemd-helper which we use in our
	# autoscripts
	addsubstvar($package, "misc:Depends", "init-system-helpers");
}

=head1 SEE ALSO

L<dh_systemd_enable(1)>, L<dh_systemd_start(1)>, L<debhelper(7)>

=head1 AUTHORS

pkg-systemd-maintainers@lists.alioth.debian.org

=cut
